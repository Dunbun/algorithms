<html>
<body bgcolor=#9ACD32>
<script language=javascript>  
   
    function binarysearch() {

        var list2 = [];
        var begin = 0;
        var len = document.getElementById('space').value.length;
        var end = len - 1;
        var mid;
        var swap;
        if (len < 10)
            for (var i = len; i <= 10; i++)
                document.getElementById('' + (i)).style.display = 'none';
        for (var i = 0; i < len; i++) {
            list2[i] = document.getElementById('space').value[i];
            document.getElementById('' + (i + 1)).style.height = Number(list2[i]) * 10;
        }

      





        search = list2[len-1];
        var i = 1000;
      
        refreshIntervalId = setInterval(function () {
            

            

            //�� ��������� ������������� ����� 
            mid = Math.floor((end + begin) / 2);
            if (end - begin == 1 && list2[end] == search) {
                document.getElementById('' + (end + 1)).style.backgroundColor = "red";
                for (var i = 1; i <= len; i++)
                    if(i!=end-1)
                    document.getElementById('' + i).style.backgroundColor = "black";



            }
            for (var i = 1; i <= len; i++)
                document.getElementById('' + i).style.backgroundColor = "black";
            for (var i = begin + 1; i <= end + 1 ; i++)
                document.getElementById('' + i).style.backgroundColor = "blue";




            document.getElementById('' + (mid + 1)).style.backgroundColor = "red";
            if (end - begin == 1 && list2[end] == search) {
                document.getElementById('' + (end + 1)).style.backgroundColor = "red";
                document.getElementById('' + (end )).style.backgroundColor = "black";
            }

            if (list2[mid] > search)
                begin = mid;
            if (list2[mid] <= search)
                end = mid;
            if (end - begin == 1 && i > 100)
                i = 2;
            i--;

            if (i == 0 ) {
                clearInterval(refreshIntervalId);
            }

        }, 1000);


      
        

    }


    



    
            
          

</script>
<table    align=center cellspacing='0'  cellpadding='0'  border=0  bgcolor=white >
<tr>
<td valign=bottom>
<input id="1" type=text  disabled style="height:100 ; width:10; vertical-align:bottom " /></td>
<td valign=bottom>
<input id="2" type=text  disabled style="height:100 ; width:10; vertical-align:bottom "/></td>
<td valign=bottom>
<input id="3" type=text  disabled style="height:100 ; width:10; vertical-align:bottom " /></td>
<td valign=bottom>
<input id="4" type=text  disabled style="height:100 ; width:10; vertical-align:bottom " /></td>
<td valign=bottom>
<input id="5" type=text  disabled style="height:100 ; width:10; vertical-align:bottom " /></td>
<td valign=bottom>
<input id="6" type=text  disabled style="height:100; width:10; vertical-align:bottom " /></td>
<td valign=bottom>
<input id="7" type=text  disabled style="height:100; width:10; vertical-align:bottom " /></td>
<td valign=bottom>
<input id="8" type=text  disabled style="height:100; width:10; vertical-align:bottom " /></td>
<td valign=bottom>
<input id="9" type=text  disabled style="height:100; width:10; vertical-align:bottom " /></td>
<td valign=bottom>
<input id="10" type=text  disabled style="height:100 ; width:10; vertical-align:bottom " /></td>
</tr>
</table>
<br />
<input type=text   onchange="show()" id='space' maxlength=10/>
<input   value='begin sorting' type=button onclick="binarysearch()" />
<img src= "binarysearch.png"  width="35%" height="70%" align=right>

<h3 align=center>
The above procedure only performs exact matches, finding the position of a target value. However, due to the ordered nature of sorted arrays, it is trivial to extend binary search to perform approximate matches. For example, binary search can be used to compute, for a given value, its rank (the number of smaller elements), predecessor (next-smallest element), successor (next-largest element), and nearest neighbor. Range queries seeking the number of elements between two values can be performed with two rank queries.[9]
Rank queries can be performed using a modified version of binary search. By returning m on a successful search, and L on an unsuccessful search, the number of elements less than the target value is returned instead.[9]
Predecessor and successor queries can be performed with rank queries. Once the rank of the target value is known, its predecessor is the element at the position given by its rank (as it is the largest element that is smaller than the target value). Its successor is the element after it (if it is present in the array) or at the next position after the predecessor (otherwise).[10] The nearest neighbor of the target value is either its predecessor or successor, whichever is closer.
Range queries are also straightforward. Once the ranks of the two values are known, the number of elements greater than or equal to the first value and less than the second is the difference of the two ranks. This count can be adjusted up or down by one according to whether the endpoints of the range should be considered to be part of the range and whether the array contains keys matching those endpoints.
</h3>
</body>
</html>